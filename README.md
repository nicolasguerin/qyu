# qyu

In-memory queue library in JavaScript, with maximum processing jobs limit and recurrent stats.
You can use demo.js as an example.

## Table of Contents

- [Installation](#installation)
- [General description](#general-description)
- [API description](#api-description)
- [Qyu events](#qyu-events)
- [Qyu data exposed](#qyu-data-exposed)
- [Qyu custom errors](#qyu-custom-errors)


## Installation

### Qyu library

Not distributed over npm. Please download source code.

### Test using mocha

Install mocha

```
npm install mocha
```

Run unit tests
```
npm test
```

### Test using demo.js

```
node demo.js
```


## General description

Qyu implementation is based on promises, meaning that a job will be processed and a promise will be resolved with the job result when execution completed.

This is how Qyu is working :

* At initialisation, an associative array is created to store jobs that will be pushed.
* When a job is pushed, a new object is created into the array, using job id as key:
```js
this.jobsQueue[id] = {
                id:id,
                prio: prio, // priority
                func:job    // the job to execute
               };
```
* When Qyu is started, jobs started to be processed via an async function `_processNext`.
* A promise is created with job execution, which will resolve when job completes its execution. Then the `done` event is emitted and a new call to `_processNext` is done to execute the next job.
* If queue is empty, the `drain` event is emitted, otherwise it continues.


## API description

### Initialisation and control

#### Create a Qyu

How to import module, create and initialise a new 'Qyu'.
It could take several parameters, otherwise values are set to default.

* rateLimit (default value : 20) - Maximum number of jobs being processed at the same time
* statsInterval (default value : 300) - When stat event is sent, in ms.

```js
const qyu = require('./qyu');

const q = new qyu({
  rateLimit: 10, // maximum number of jobs being processed at the same time
  statsInterval: 2000 // When stat event is sent, in ms
});
```

#### Pushing a job

How to push any kind of function into the 'Qyu'. 
It takes two parameters. Return value is a unique job id.

* job (mandatory) - A function that will be asynchronously executed.
* priority (default value : 5) - Optional priority, from 1 to 10, 1 being the highest priority. If value specified above 10, value is set to the lowest priority 10.

```js
const id = q.push(
    job, // function to execute
    3,   // optional priority, from 1 to 10, 1 being the highest priority - default: 5
  ); // returns the internal id
```

#### Start the 'Qyu'

How to start processing jobs that have been pushed into the 'Qyu'.
It returns a promise resolved when 'q' has started (first time) or unpaused.

```js
await q.start(); // returns a promise resolved when `q` has started (first time) or unpaused
```

#### Pause the 'Qyu'

How to pause jobs processing.
It returns a promise resolved when 'q' has paused (no jobs being processed).

```js
await q.pause(); // returns a promise resolved when `q` has paused (no jobs being processed)
```

#### Wait for a job to complete

How to wait for a job to complete.
A promise resolves when the job is complete with the job result.

* job id (mandatory) - id of the job to wait for.

```js
const res = await q.wait(id); // resolves when the job is complete with the job result
```


### Qyu events

#### Job done

Event thrown when a job is complete.

```js
q.on('done', ({ id, result }) => {
  console.log(`Job done ${id}`); // `id` is an internal identifier generated by `qyu`
  console.log("result : " + result.Hello);
});
```

#### Job error

Event thrown when an error occured during job execution.

```js
q.on('error', ({ id, error }) => {
  console.log(`Job ${id} threw an error: ${error.message}`);
});
```

#### Qyu drain

Event thrown when the 'Qyu' is drained;

```js
q.on('drain', () => {
  console.log('No more jobs to do');
});
```

#### Qyu stats

Event thrown reccurently depending on 'statsInterval', giving number of jobs processed per second.

```js
q.on('stats', ({ nbJobsPerSecond }) => {
  console.log(`${nbJobsPerSecond} jobs/s processed`);
});
```


### Qyu data exposed

#### Get rate limit

Returns the rate limit set at initialisation.

```js
var limit = q.getRateLimit(); // returns the rate limit set at initialisation
```

#### Get stats interval

Returns the stats interval set at initialisation.

```js
var statsInterval = q.getStatsInterval(); // returns the stats interval set at initialisation
```

#### Get qyu length

Returns queue length.

```js
var length = q.getQyuLength(); // returns queue length
```

#### Check if Qyu is started

Returns a boolean, true if the queue has been started.

```js
var isStarted = q.isQyuStarted(); // returns a boolean, true if the queue has been started.
```

#### Get job priority

Returns priority of a job.

```js
var priority = q.getJobPriority(); // returns priority of a job
```

#### Set job priority

Set a new priority to a job.

* job id (mandatory)
* priority (mandatory) - new prority to set

```js
q.setJobPriority(jobId, newPrio);
```


### Qyu custom errors

Creating custom errors allows a better identification in bad behaviour of the lib.

    * QyuAlreadyStartedError : error thrown when trying to start qyu twice
  	* QyuMaxCapacityError : error thrown when trying to push a job over the capacity limitation,
  	* QyuJobNotDefinedError : error thrown when trying to process an undefined job,
  	* QyuJobExecutionError : error thrown when an error occures during job execution.